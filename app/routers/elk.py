"""ELK SIEM API routes for RansomRun platform.

Provides Elasticsearch/OpenSearch integration for security alerts and SOAR triggers.
"""

import os
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from ..database import get_db
from ..integrations.elk_client import ELKClient, get_elk_client_from_env, get_elk_client_from_config
from ..utils.mitre import load_mitre_mapping, map_rule_to_mitre, get_technique_heatmap_data
from ..services.soar_trigger import SOARTrigger, evaluate_alert_for_playbook, get_playbook_recommendations

router = APIRouter(prefix="/elk", tags=["ELK SIEM"])


def get_elk_client(db: Session = Depends(get_db)) -> ELKClient:
    """Get ELK client, preferring database config over env."""
    client = get_elk_client_from_config(db)
    if not client:
        client = get_elk_client_from_env()
    return client


@router.get("/status")
def get_elk_status(db: Session = Depends(get_db)):
    """
    Get ELK/Elasticsearch connection status.
    
    Tests the connection and returns cluster info.
    """
    client = get_elk_client(db)
    
    try:
        status = client.test_connection()
        return {
            'source': 'ELK',
            **status
        }
    except Exception as e:
        return {
            'source': 'ELK',
            'connected': False,
            'error': str(e)
        }


@router.get("/agents")
def get_agents(
    limit: int = Query(500, le=1000, description="Maximum number of agents to return"),
    db: Session = Depends(get_db)
):
    """
    Get all endpoints/hosts from ELK.
    
    Returns list of unique hosts seen in the logs with their status.
    """
    client = get_elk_client(db)
    
    try:
        agents = client.get_agents(limit=limit)
        active_count = len([a for a in agents if a.get('status') == 'active'])
        
        return {
            'agents': agents,
            'total': len(agents),
            'active': active_count,
            'inactive': len(agents) - active_count,
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/alerts")
def get_alerts(
    limit: int = Query(50, le=500, description="Maximum number of alerts to return"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
    host_name: Optional[str] = Query(None, description="Filter by endpoint name"),
    min_severity: Optional[int] = Query(None, ge=0, le=100, description="Minimum severity (0-100)"),
    hours: int = Query(24, ge=1, le=720, description="Time range in hours"),
    db: Session = Depends(get_db)
):
    """
    Get security alerts from database (generated by detection engine).
    
    Returns alerts enriched with MITRE ATT&CK mapping.
    """
    from datetime import datetime, timedelta
    from ..models import Alert, Host
    
    try:
        # Query alerts from database instead of Elasticsearch
        query = db.query(Alert)
        
        # Time filter
        since = datetime.utcnow() - timedelta(hours=hours)
        query = query.filter(Alert.timestamp >= since)
        
        # Host filter
        if host_name:
            host = db.query(Host).filter(Host.name.ilike(f"%{host_name}%")).first()
            if host:
                query = query.filter(Alert.host_id == host.id)
        
        # Severity filter
        if min_severity is not None:
            query = query.filter(Alert.severity >= min_severity)
        
        # Order and paginate
        query = query.order_by(Alert.timestamp.desc())
        total = query.count()
        alerts_db = query.offset(offset).limit(limit).all()
        
        # Convert to response format
        alerts = []
        for a in alerts_db:
            # Extract MITRE from raw data if available
            raw = a.raw or {}
            mitre = raw.get('mitre', [])
            
            alerts.append({
                'id': str(a.id),
                'timestamp': a.timestamp.isoformat() if a.timestamp else None,
                'host': a.agent_name or (a.host.name if a.host else 'Unknown'),
                'rule_id': a.rule_id,
                'rule_name': raw.get('rule_name', a.rule_id),
                'description': a.rule_description,
                'severity': a.severity,
                'severity_label': 'CRITICAL' if a.severity >= 15 else 'HIGH' if a.severity >= 10 else 'MEDIUM' if a.severity >= 5 else 'LOW',
                'mitre': mitre,
                'source': raw
            })
        
        # Calculate stats
        high_severity = [a for a in alerts if a.get('severity', 0) >= 10]
        
        return {
            'alerts': alerts,
            'count': len(alerts),
            'total': total,
            'high_severity_count': len(high_severity),
            'offset': offset,
            'limit': limit,
            'source': 'DATABASE'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/alerts/search")
def search_alerts(
    q: str = Query(..., min_length=1, description="Search query"),
    limit: int = Query(50, le=500, description="Maximum number of results"),
    db: Session = Depends(get_db)
):
    """
    Search ELK alerts by query string.
    
    Searches across alert fields using Elasticsearch query string syntax.
    """
    client = get_elk_client(db)
    
    try:
        alerts = client.search_alerts(query_string=q, limit=limit)
        
        return {
            'query': q,
            'alerts': alerts,
            'count': len(alerts),
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/alerts/{alert_id}")
def get_alert_detail(alert_id: str, db: Session = Depends(get_db)):
    """
    Get detailed alert information by ID.
    
    Args:
        alert_id: The Elasticsearch document ID.
    """
    client = get_elk_client(db)
    
    try:
        alert = client.get_alert_by_id(alert_id)
        if not alert:
            raise HTTPException(status_code=404, detail="Alert not found")
        
        return {
            'alert': alert,
            'source': 'ELK'
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/stats")
def get_stats(
    hours: int = Query(24, ge=1, le=720, description="Time range in hours"),
    db: Session = Depends(get_db)
):
    """
    Get ELK SIEM dashboard statistics from database.
    
    Returns counts for endpoints, alerts, and severity breakdown.
    """
    from datetime import datetime, timedelta
    from ..models import Alert, Host
    from sqlalchemy import func
    
    try:
        since = datetime.utcnow() - timedelta(hours=hours)
        
        # Get alert counts from database
        total_alerts = db.query(Alert).filter(Alert.timestamp >= since).count()
        high_severity = db.query(Alert).filter(
            Alert.timestamp >= since,
            Alert.severity >= 10
        ).count()
        
        # Get endpoint counts
        total_endpoints = db.query(Host).count()
        active_endpoints = db.query(Host).filter(Host.status == 'ONLINE').count()
        
        return {
            'total_endpoints': total_endpoints,
            'active_endpoints': active_endpoints,
            'total_alerts': total_alerts,
            'high_severity_alerts': high_severity,
            'source': 'DATABASE',
            'time_range_hours': hours
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/mitre/heatmap")
def get_mitre_heatmap(
    hours: int = Query(168, ge=1, le=720, description="Time range in hours (default 7 days)"),
    db: Session = Depends(get_db)
):
    """
    Get MITRE ATT&CK technique frequency data for heatmap visualization.
    
    Returns technique IDs with their occurrence counts from database alerts.
    """
    from datetime import datetime, timedelta
    from ..models import Alert
    from collections import Counter
    
    try:
        since = datetime.utcnow() - timedelta(hours=hours)
        
        # Get alerts from database
        alerts = db.query(Alert).filter(Alert.timestamp >= since).all()
        
        # Count MITRE techniques
        technique_counts = Counter()
        for alert in alerts:
            raw = alert.raw or {}
            mitre = raw.get('mitre', [])
            for technique in mitre:
                technique_counts[technique] += 1
        
        # Format for heatmap
        techniques = [
            {'technique_id': tid, 'count': count}
            for tid, count in technique_counts.most_common(50)
        ]
        
        return {
            'techniques': techniques,
            'total_techniques': len(technique_counts),
            'source': 'DATABASE',
            'time_range_hours': hours
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/mitre/mapping")
def get_mitre_mapping_endpoint():
    """
    Get the full MITRE ATT&CK mapping.
    
    Returns all rule ID to MITRE technique mappings (local mapping file).
    """
    mapping = load_mitre_mapping()
    return {
        'mapping': mapping,
        'count': len(mapping),
        'source': 'local'
    }


@router.get("/mitre/mapping/{rule_id}")
def get_mitre_for_rule(rule_id: str):
    """
    Get MITRE ATT&CK mapping for a specific rule.
    
    Args:
        rule_id: The detection rule ID.
    """
    mitre_info = map_rule_to_mitre(rule_id)
    
    if not mitre_info:
        return {
            'rule_id': rule_id,
            'found': False,
            'technique': 'N/A',
            'name': 'Unknown'
        }
    
    return {
        'rule_id': rule_id,
        'found': True,
        **mitre_info
    }


@router.get("/timeline")
def get_alerts_timeline(
    hours: int = Query(24, ge=1, le=168, description="Time range in hours"),
    interval: str = Query('1h', description="Aggregation interval (e.g., 1h, 30m)"),
    db: Session = Depends(get_db)
):
    """
    Get alerts aggregated over time for timeline visualization.
    
    Returns time-bucketed alert counts with severity breakdown.
    """
    client = get_elk_client(db)
    
    try:
        timeline = client.get_alerts_timeline(
            time_range_hours=hours,
            interval=interval
        )
        return {
            'timeline': timeline,
            'count': len(timeline),
            'time_range_hours': hours,
            'interval': interval,
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ============ SOAR / Playbook Trigger Endpoints ============

@router.get("/soar/evaluate")
def evaluate_alerts_for_playbooks(
    hours: int = Query(24, ge=1, le=168, description="Time range in hours"),
    min_severity: int = Query(0, ge=0, le=100, description="Minimum severity to evaluate"),
    db: Session = Depends(get_db)
):
    """
    Evaluate recent alerts and determine which should trigger playbooks.
    
    Returns alerts with trigger decisions and recommended actions.
    """
    client = get_elk_client(db)
    
    try:
        # Get alerts from ELK
        alerts = client.get_alerts(
            limit=100,
            min_severity=min_severity,
            time_range_hours=hours
        )
        
        # Evaluate each alert for playbook triggers
        trigger = SOARTrigger()
        evaluations = trigger.evaluate_alerts_batch(alerts)
        
        # Filter to only triggered alerts
        triggered = [e for e in evaluations if e['should_trigger']]
        
        # Get priority summary
        priority_summary = trigger.get_priority_summary(alerts)
        
        return {
            'total_alerts': len(alerts),
            'triggered_count': len(triggered),
            'triggered_alerts': triggered,
            'priority_summary': priority_summary,
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/soar/evaluate-alert")
def evaluate_single_alert(alert: dict):
    """
    Evaluate a single alert for playbook trigger.
    
    Accepts an alert object and returns trigger decision with recommended actions.
    """
    try:
        result = evaluate_alert_for_playbook(alert)
        return {
            'evaluation': result,
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/soar/recommendations")
def get_soar_recommendations(
    hours: int = Query(24, ge=1, le=168, description="Time range in hours"),
    db: Session = Depends(get_db)
):
    """
    Get playbook recommendations for recent high-severity alerts.
    
    Returns only alerts that should trigger a response with their recommended playbooks.
    """
    client = get_elk_client(db)
    
    try:
        # Get high-severity alerts (41+)
        alerts = client.get_alerts(
            limit=50,
            min_severity=41,
            time_range_hours=hours
        )
        
        # Get recommendations
        recommendations = get_playbook_recommendations(alerts)
        
        # Group by recommended playbook
        by_playbook = {}
        for rec in recommendations:
            playbook = rec.get('recommended_playbook', 'unknown')
            if playbook not in by_playbook:
                by_playbook[playbook] = []
            by_playbook[playbook].append(rec)
        
        return {
            'total_recommendations': len(recommendations),
            'recommendations': recommendations,
            'by_playbook': by_playbook,
            'source': 'ELK'
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/mode")
def get_siem_mode():
    """
    Get current SIEM mode (mock or elastic).
    """
    siem_mode = os.getenv('SIEM_MODE', 'mock').lower()
    return {
        'mode': siem_mode,
        'is_mock': siem_mode == 'mock',
        'is_live': siem_mode == 'elastic'
    }
